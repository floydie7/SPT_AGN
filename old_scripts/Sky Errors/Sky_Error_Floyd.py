"""
Sky_Error_Floyd.py
Author: Benjamin Floyd

This is a rewrite of Bandon Decker's sky_error.py library to clean up and optimize the functions as well as bringing the
code up to PEP 8 standards. It also utilizes PyRAF so that the user does not have to run a file in the IRAF environment 
separately from the python functions.
"""

from __future__ import print_function, division

import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits, ascii
from astropy.table import Table
from pyraf import iraf
from scipy import optimize as op


def generate_apertures(image_name, output_coo, aper_size, xmin=0, xmax=None, ymin=0, ymax=None):
    """
    Generates a coordinate file for the apertures to be placed on the image. 
    :param image_name: 
        File name of the image.
    :param output_coo: 
        File name of the output coordinates file.
    :param aper_size: 
        The aperture diameter in pixels.
    :param xmin: 
        Minimum pixel in the x-direction allowed to place an aperture center on. Defaults to 0.
    :param xmax: 
        Maximum pixel in the x-direction allowed to place an aperture center on. Defaults to the size of the image.
    :param ymin: 
        Minimum pixel in the y-direction allowed to place an aperture center on. Defaults to 0.
    :param ymax: 
        Maximum pixel in the x-direction allowed to place an aperture center on. Defaults to the size of the image.
    :type image_name: str
    :type output_coo: str
    :type aper_size: int
    :type xmin: int
    :type xmax: int
    :type ymin: int
    :type ymax: int
    """

    # Announce ourselves.
    print('Generating Apertures.')

    # If the user does not specify a maximum pixel bound query the image header for the maximum pixel coordinate.
    if not xmax:
        xmax = fits.getval(image_name, 'NAXIS1')
    if not ymax:
        ymax = fits.getval(image_name, 'NAXIS2')

    # Convert the aperture diameter into a radius as this is the value qphot requires. Use flooring division to preserve
    # integer value.
    aper_rad = aper_size // 2

    # Generate lists for the x and y coordinates of the aperture centers.
    x_coord = np.arange(xmin + aper_rad, xmax, aper_size)
    y_coord = np.arange(ymin + aper_rad, ymax, aper_size)

    # Write the coordinates to the specified file.
    with open(output_coo, 'w') as coo:
        coo.write('X Y\n')
        for x in x_coord:
            for y in y_coord:
                coo.write('{0} {1}\n'.format(x, y))


def run_qphot(image_name, coord_list, output_file, aper_size, zpt_mag, sky_annul=10, sky_dannul=3):
    """
    Uses PyRAF to call the qphot IRAF task on the specified image and using the coordinate file and aperture diameter
    given by the user. 
    :param image_name:
        File name of the image to run qphot on.
    :param coord_list: 
        File name of the coordinate file generated by the generate_apertures function.
    :param output_file: 
        File name of the qphot output file. 
    :param aper_size: 
        The aperture diameter in pixels.
    :param zpt_mag: 
        The zero point magnitude.
    :param sky_annul: 
        The inner radius of the sky annulus in pixels. Defaults to 10 pixels.
    :param sky_dannul: 
        The width of the sky annulus in pixels. Defaults to 3 pixels.
    :type image_name: str
    :type coord_list: str
    :type output_file: str
    :type aper_size: int
    :type zpt_mag: float
    :type sky_annul: int
    :type sky_dannul: int
    """

    # Announce ourselves.
    print('Running qphot.')

    # Convert the aperture diameter into a radius as this is the value qphot requires. Use flooring division to preserve
    # integer value.
    aper_rad = aper_size // 2

    # Load the apphot subpackage.
    iraf.apphot(_doprint=0)

    # Run qphot in batch mode.
    iraf.qphot(image=image_name, cbox=0, annulus=sky_annul, dannulus=sky_dannul, apertures=aper_rad, coords=coord_list,
               output=output_file, zmag=zpt_mag, interactive='no')


def catalog_management(mag_catalogs, coverage_images, min_cov):
    """
    Inputs the .selection_band qphot files, filters out any apertures with centers on bad coverage values, then if multiple
    catalogs are given for stacking purposes, merges those catalogs into one master catalog. 
    :param mag_catalogs: 
        File name of the qphot .selection_band file(s). Can be either a single qphot catalog or a list of qphot catalogs.
        If a list is given, the function will return the concatenation of the input catalogs. 
    :param coverage_images: 
        File name of the image coverage map(s). Can either be a single image or a list of images. If a list is given, 
        the dimensions of the list must equal the dimensions of the mag_catalogs list.
    :param min_cov: 
        Minimum coverage value allowed for the aperture data to be kept.
    :return output_table:
        An Astropy table with the pixel coordinates of the center of each aperture and the corresponding flux value
        contained within.
    :raises TypeError:
        If the arguments `mag_catalogs` and `coverage_images` are not of the same type.
    :raises IndexError:
        If the arguments `mag_catalogs` and `coverage_image` are not of the same dimension.
    :type mag_catalogs: str or list
    :type coverage_images: str or list
    :type min_cov: float
    :rtype: astropy.table object
    """

    # Announce ourselves.
    print('Preforming catalog management.')

    # First check the type of the mag_catalogs and coverage_images arguments.
    if isinstance(mag_catalogs, str) and isinstance(coverage_images, str):
        # Place the strings inside a list so we can treat it in the same way as with multiple catalogs.
        cat_list = [mag_catalogs]
        cov_list = [coverage_images]

    elif isinstance(mag_catalogs, list) and isinstance(coverage_images, list):
        # Let's use the same local variable name for both cases.
        cat_list = mag_catalogs
        cov_list = coverage_images
    else:
        # In case the user mixes the argument types.
        raise TypeError("Arguments `mag_catalogs` and `coverage_images` must be of same type ('str' or 'list').")

    # Check that mag_catalogs and coverage_images are of the same length.
    if len(cat_list) != len(cov_list):
        raise IndexError("Arguments `mag_catalogs` and `coverage_images` must be of the same dimension.")

    # Set up containers to store accepted values in.
    x_coords = []
    y_coords = []
    flux_value = []
    for i in range(len(cat_list)):
        # Read in the data.
        catalog = ascii.read(cat_list[i])
        coverage = fits.getdata(cov_list[i], ignore_missing_end=True)

        # Check the coverage on aperture centers is at least the minimum value.
        for j in range(len(catalog)):
            if coverage[int(catalog['YCENTER'][j])][int(catalog['XCENTER'][j])] >= min_cov:
                x_coords.append(catalog['XCENTER'][j])
                y_coords.append(catalog['YCENTER'][j])
                flux_value.append(catalog['FLUX'][j])

    # Collect the lists into one single Astropy table.
    output_table = Table([x_coords, y_coords, flux_value], names=['x', 'y', 'flux'])

    return output_table


def gaussian(x, mu, sigma, a):
    """
    Just a utility function for op.curve_fiting to use.
    :param x: Random variable.
    :param mu: Mean of distribution.
    :param sigma: Standard deviation of distribution.
    :param a: Prefactor of the distribution.
    :return: (Non-normalized) probability at random variable x.
    :type x: array-like
    :type mu: float
    :type sigma: float
    :type a: float
    :rtype: float
    """
    return a * np.exp(-(x - mu) ** 2 / (2 * sigma ** 2))


def fit_gaussian(catalog, nbins=40, hist_range=(-1., 1.), cutoff=0.2):
    """
    Generates the histogram of the flux data and finds the best fit of the histogram using a gaussian model.
    :param catalog: 
        Astropy table catalog containing flux data within apertures. 
    :param nbins: 
        Number of bins to divide the data into the histogram. Defaults to 40.
    :param hist_range: 
        The lower and upper range of the histogram. Values outside this range are ignored. Defaults to (-1, 1).
    :param cutoff: 
        The uppermost value of the histogram to apply the fit on. Defaults to 0.2.
    :returns mid_pts:
        The midpoints of the histogram bins.
    :returns hist:
        The values of the histogram.
    :returns opt_params:
        The optimal values for the parameters of the Gaussian. First element is the best-fit mean of the distribution, 
        second element is the best-fit standard deviation of the distribution.
    :type catalog: astropy.table object
    :type nbins: int
    :type hist_range: tuple
    :type cutoff: float
    :rtype mid_pts: list
    :rtype hist: ndarray
    :rtype opt_params: list of dtype float
    """

    # Announce ourselves.
    print('Creating histogram.')

    # Select the flux column in the catalog.
    fluxes = catalog['flux']

    # Create the histogram and the bin endpoints.
    hist, bin_edges = np.histogram(fluxes, bins=nbins, range=hist_range)

    # We want to fit our Gaussian to the midpoint of the bins not the endpoints.
    mid_pts = []
    for i in range(len(bin_edges) - 1):
        mid_pts.append((bin_edges[i] + bin_edges[i+1]) * 0.5)

    # We only want to fit the Gaussian up to the cutoff point of the histogram.
    mid_pts = np.array(mid_pts)
    fit_mid_pts = mid_pts[np.where(mid_pts <= cutoff)]

    # Preform the curve fitting
    print('Preforming curve fitting.')
    opt_params, _ = op.curve_fit(gaussian, fit_mid_pts, hist[:len(fit_mid_pts)])

    return mid_pts, hist, opt_params


def flux_error(sigma, aper_corr, flux_conv):
    """
    Converts the best-fit error parameter found in fit_gaussian into appropriate flux units and preforms an aperture
    correction.
    :param sigma:
        Best-fit sky error value as calculated by the fit_gaussian function.
    :param aper_corr: 
        Aperture correction factor for the flux measured in the aperture size used in qphot to a standard aperture.
    :param flux_conv: 
        Conversion factor to convert the sky error from the raw units into standard flux units.
    :return: 
        Aperture corrected sky error in standard flux units.
    :type sigma: float
    :type flux_conv: float
    :type aper_corr: float
    :rtype: float
    """

    # Take absolute value of sigma and apply conversion and correction factors.
    sky_error = np.abs(sigma) * flux_conv * aper_corr

    return sky_error


def make_plot(mid_pts, hist, opt_params, sky_error, image_name, cutoff=0.2):
    """
    Creates a plot showing a histogram of the flux counts found via qphot and a Gaussian best-fit line.
    :param mid_pts: 
        Midpoints of the histogram bins.
    :param hist: 
        The values of the histogram.
    :param opt_params: 
        Best-fit parameters of the Gaussian. Parameters are the mean and standard deviation respectively.
    :param sky_error:
        The best-fit standard deviation in standard flux units and aperture corrected.
    :param image_name:
        The image name to be displayed in the title of the plot.
    :param cutoff:
        The uppermost value of the histogram the fit was calculated on. Defaults to 0.2.
    :type mid_pts: ndarray
    :type hist: ndarray
    :type opt_params: list
    :type sky_error: float
    :type image_name: str
    :type cutoff: float
    """

    # Announce ourselves.
    print('Plotting result.')

    fit_mid_pts = mid_pts[np.where(mid_pts <= cutoff)]

    bin_width = (mid_pts[0] - mid_pts[1])

    # Best-fit parameters
    mu = opt_params[0]
    sigma = opt_params[1]
    a = opt_params[2]

    # Make the plot.
    fig, ax = plt.subplots()
    ax.grid(color='lightgrey')
    ax.bar(mid_pts, hist, align='center', width=bin_width, color='lightblue', zorder=3)
    ax.plot(fit_mid_pts, gaussian(fit_mid_pts, mu, sigma, a), color='darkred', linestyle='--', linewidth=2, zorder=4,
            label='$\mu$ = {0:.3f}, $\sigma$ = {1:.3e} MJy/sr'.format(mu, sigma))
    handles, labels = ax.get_legend_handles_labels()
    handles.append(mpatches.Patch(color='none', label='Sky Error = {0:.3f} $\mu$Jy'.format(sky_error)))
    ax.legend(handles=handles, loc='upper left', frameon=False)
    ax.set(title='Sky Error for {0}'.format(image_name), xlabel='Flux ($\mu$Jy)', xlim=[-0.5, 0.5])
    fig.savefig('Data/sky_errors/plots/{0}_sky_error.pdf'.format(image_name), format='pdf')
